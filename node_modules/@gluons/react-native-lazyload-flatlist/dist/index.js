var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { debounce } from 'lodash-es';
import React, { useEffect, useState } from 'react';
import { FlatList } from 'react-native';
import delay from './delay';
import sliceData from './sliceData';
const LazyLoadFlatList = function (props) {
    const { data, itemLimit, refreshing, onEndReached, onLoadMore } = props, restProps = __rest(props, ["data", "itemLimit", "refreshing", "onEndReached", "onLoadMore"]);
    const [allData, setAllData] = useState([]);
    const [currentData, setCurrentData] = useState([]);
    const [lastLoadIndex, setLastLoadIndex] = useState(0);
    const [loading, setLoading] = useState(false);
    const callOnLoadMore = async (moreData) => {
        if (!onLoadMore) {
            return moreData;
        }
        setLoading(true);
        try {
            // Normalize result to `Promise` via `Promise.resolve`
            const loadMoreResult = await Promise.resolve(onLoadMore(moreData));
            if (Array.isArray(loadMoreResult)) {
                return loadMoreResult;
            }
            return moreData;
        }
        catch (_) {
            return moreData;
        }
        finally {
            setLoading(false);
        }
    };
    const loadMore = async () => {
        if (allData.length === currentData.length) {
            return;
        }
        setLoading(true);
        await delay(300);
        try {
            const { slicedData, lastIndex } = sliceData(allData, itemLimit, lastLoadIndex);
            const finalData = await callOnLoadMore(slicedData);
            const newCurrentData = currentData.concat(finalData);
            setCurrentData(newCurrentData);
            setLastLoadIndex(lastIndex);
        }
        catch (err) {
            console.error(err);
        }
        finally {
            setLoading(false);
        }
    };
    useEffect(() => {
        if (!data || data.length === 0) {
            setAllData([]);
            setCurrentData([]);
            return;
        }
        setAllData(data);
        setCurrentData([]);
        setLastLoadIndex(0);
        const { slicedData, lastIndex } = sliceData(data, itemLimit, 0);
        (async () => {
            const finalData = await callOnLoadMore(slicedData);
            setCurrentData(finalData);
            setLastLoadIndex(lastIndex);
        })();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [data, itemLimit]);
    return (<FlatList {...restProps} data={currentData} refreshing={loading || refreshing} onEndReached={debounce(info => {
            if (onEndReached) {
                onEndReached(info);
            }
            void loadMore();
        }, 500)}/>);
};
const defaultProps = {
    itemLimit: 10,
    onLoadMore: () => { }
};
LazyLoadFlatList.defaultProps = defaultProps;
export default LazyLoadFlatList;
